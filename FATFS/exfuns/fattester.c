#include "fattester.h"	 
#include "usart.h"
#include "exfuns.h"	  
#include "ff.h"
#include "string.h"
#include "common.h"

    
//为磁盘注册工作区	 
//path:磁盘路径，比如"0:"、"1:"
//mt:0，不立即注册（稍后注册）；1，立即注册
//返回值:执行结果
FRESULT mf_mount(u8* path,u8 mt)
{		   
	return f_mount(fs,(const TCHAR*)path,mt); 
}

//打开路径下的文件
//path:路径+文件名
//mode:打开模式
//返回值:执行结果
FRESULT mf_open(u8*path,u8 mode)
{
	FRESULT res = FR_OK;

	res = f_open(file,(const TCHAR*)path,mode);//打开文件夹

	return res;
}

//关闭文件
//返回值:执行结果
FRESULT mf_close(void)
{
	FRESULT res = FR_OK;
	
	res = f_close(file);

	return res;
}

//读出数据
//len:读出的长度
//返回值:执行结果
u32 mf_read(u32 len)
{
	u32 i,t;
	FRESULT res = FR_OK;
	u32 tlen = 0;

#ifdef DEBUG_LOG
	printf("\r\nRead file data is:\r\n");
#endif
	
	for(i = 0; i < len / 512; i ++)
	{
		res = f_read(file,fatbuf,512,&br);

		if(res)
		{
#ifdef DEBUG_LOG
			printf("Read Error:%d\r\n",res);
#endif
			break;
		}
		else
		{
			tlen += br;

			for(t = 0; t < br; t ++)
			{
#ifdef DEBUG_LOG
				printf("%c",fatbuf[t]);
#endif
			}
		}
	}

	if(len % 512)
	{
		res = f_read(file,fatbuf,len % 512,&br);

		if(res)	//读数据出错了
		{
#ifdef DEBUG_LOG
			printf("\r\nRead Error:%d\r\n",res); 
#endif			
		}
		else
		{
			tlen += br;
			
			for(t = 0; t < br; t ++)
			{
#ifdef DEBUG_LOG
				printf("%c",fatbuf[t]); 
#endif
			}
		}	 
	}
	
	if(tlen)
	{
#ifdef DEBUG_LOG
		printf("\r\nReaded data len:%d\r\n",tlen);//读到的数据长度
#endif
	}
	
#ifdef DEBUG_LOG
	printf("Read data over\r\n");
#endif
	
	return tlen;
}
//写入数据
//dat:数据缓存区
//len:写入长度
//返回值:执行结果
FRESULT mf_write(u8*dat,u16 len)
{			    
	FRESULT res = FR_OK;	   					   

#ifdef DEBUG_LOG
	printf("\r\nBegin Write file...\r\n");
	printf("Write data len:%d\r\n",len);
#endif
	
	res = f_write(file,dat,len,&bw);

#ifdef DEBUG_LOG
	if(res)
	{
		printf("Write Error:%d\r\n",res);   
	}
	else
	{
		printf("Writed data len:%d\r\n",bw);
	}		

	printf("Write data over.\r\n");
#endif	

	return res;
}

//打开目录
//path:路径
//返回值:执行结果
FRESULT mf_opendir(u8* path)
{
	return f_opendir(&dir,(const TCHAR*)path);	
}

//关闭目录 
//返回值:执行结果
FRESULT mf_closedir(void)
{
	return f_closedir(&dir);	
}

//打读取文件夹
//返回值:执行结果
FRESULT mf_readdir(void)
{
	FRESULT res = FR_OK;
	char *fn;			 
		  
	res = f_readdir(&dir,&fileinfo);//读取一个文件的信息
	
	if(res != FR_OK || fileinfo.fname[0] == 0)
	{
		return res;//读完了.
	}

	fn = fileinfo.fname;;

#ifdef DEBUG_LOG
	printf("\r\n DIR info:\r\n");
	printf("dir.id:%d\r\n",dir.id);
	printf("dir.index:%d\r\n",dir.index);
	printf("dir.sclust:%d\r\n",dir.sclust);
	printf("dir.clust:%d\r\n",dir.clust);
	printf("dir.sect:%d\r\n",dir.sect);	  

	printf("\r\n");
	printf("File Name is:%s\r\n",fn);
	printf("File Size is:%d\r\n",fileinfo.fsize);
	printf("File data is:%d\r\n",fileinfo.fdate);
	printf("File time is:%d\r\n",fileinfo.ftime);
	printf("File Attr is:%d\r\n",fileinfo.fattrib);
	printf("\r\n");
#endif

	return res;
}			 

//遍历文件
//path:路径
//返回值:执行结果
FRESULT mf_scan_files(u8 * path)
{
	FRESULT res = FR_OK;	  
    char *fn;   /* This function is assuming non-Unicode cfg. */
	  
    res = f_opendir(&dir,(const TCHAR*)path); //打开一个目录
	
    if (res == FR_OK) 
	{	
#ifdef DEBUG_LOG
		printf("\r\n"); 
#endif
		
		while(1)
		{
	        res = f_readdir(&dir, &fileinfo);                   //读取目录下的一个文件
			
	        if (res != FR_OK || fileinfo.fname[0] == 0) 
			{
				break;  //错误了/到末尾了,退出
			}
			   
        	fn = fileinfo.fname;
			
#ifdef DEBUG_LOG
			printf("%s/", path);//打印路径	
			printf("%s\r\n", fn);//打印文件名	
#endif			
		} 
    }	  

    return res;	  
}

//显示剩余容量
//drv:盘符
//返回值:剩余容量(字节)
u32 mf_showfree(u8 *drv)
{
	FATFS *fs1;
	FRESULT res = FR_OK;
    u32 fre_clust = 0, fre_sect = 0, tot_sect = 0;
	
    //得到磁盘信息及空闲簇数量
    res = f_getfree((const TCHAR*)drv,(DWORD*)&fre_clust, &fs1);
    if(res==0)
	{											   
	    tot_sect = (fs1->n_fatent - 2) * fs1->csize;//得到总扇区数
	    fre_sect = fre_clust * fs1->csize;			//得到空闲扇区数
		
#if _MAX_SS!=512
		tot_sect *= fs1->ssize / 512;
		fre_sect *= fs1->ssize / 512;
#endif
		
#ifdef DEBUG_LOG
		if(tot_sect < 20480)//总容量小于10M
		{
		    /* Print free space in unit of KB (assuming 512 bytes/sector) */
		    printf("\r\n磁盘总容量:%d KB\r\n"
		           "可用空间:%d KB\r\n",
		           tot_sect>>1,fre_sect>>1);
		}
		else
		{
		    /* Print free space in unit of KB (assuming 512 bytes/sector) */
		    printf("\r\n磁盘总容量:%d MB\r\n"
		           "可用空间:%d MB\r\n",
		           tot_sect>>11,fre_sect>>11);
		}
#endif
	}

	return fre_sect;
}	

//文件读写指针偏移
//offset:相对首地址的偏移量
//返回值:执行结果.
FRESULT mf_lseek(u32 offset)
{
	return f_lseek(file,offset);
}

//读取文件当前读写指针的位置.
//返回值:位置
u32 mf_tell(void)
{
	return f_tell(file);
}

//读取文件大小
//返回值:文件大小
u32 mf_size(void)
{
	return f_size(file);
} 

//创建目录
//pname:目录路径+名字
//返回值:执行结果
FRESULT mf_mkdir(u8*pname)
{
	return f_mkdir((const TCHAR *)pname);
}

//格式化
//path:磁盘路径，比如"0:"、"1:"
//mode:模式
//au:簇大小
//返回值:执行结果
FRESULT mf_fmkfs(u8* path,u8 mode,u16 au)
{
	return f_mkfs((const TCHAR*)path,mode,au);//格式化,drv:盘符;mode:模式;au:簇大小
} 

//删除文件/目录
//pname:文件/目录路径+名字
//返回值:执行结果
FRESULT mf_unlink(u8 *pname)
{
	return  f_unlink((const TCHAR *)pname);
}

//修改文件/目录名字(如果目录不同,还可以移动文件哦!)
//oldname:之前的名字
//newname:新名字
//返回值:执行结果
FRESULT mf_rename(u8 *oldname,u8* newname)
{
	return  f_rename((const TCHAR *)oldname,(const TCHAR *)newname);
}

//获取盘符（磁盘名字）
//path:磁盘路径，比如"0:"、"1:"  
void mf_getlabel(u8 *path)
{
	u8 buf[20];
	u32 sn = 0;
	u8 res;

	res = f_getlabel ((const TCHAR *)path,(TCHAR *)buf,(DWORD*)&sn);

#ifdef DEBUG_LOG
	if(res == FR_OK)
	{
		printf("\r\n磁盘%s 的盘符为:%s\r\n",path,buf);
		printf("磁盘%s 的序列号:%X\r\n\r\n",path,sn); 
	}
	else 
	{
		printf("\r\n获取失败，错误码:%X\r\n",res);
	}
#endif
}
//设置盘符（磁盘名字），最长11个字符！！，支持数字和大写字母组合以及汉字等
//path:磁盘号+名字，比如"0:ALIENTEK"、"1:OPENEDV"  
void mf_setlabel(u8 *path)
{
	u8 res;
	
	res = f_setlabel ((const TCHAR *)path);
	
#ifdef DEBUG_LOG
	if(res == FR_OK)
	{
		printf("\r\n磁盘盘符设置成功:%s\r\n",path);
	}
	else 
	{
		printf("\r\n磁盘盘符设置失败，错误码:%X\r\n",res);
	}
#endif
} 

//从文件里面读取一段字符串
//size:要读取的长度
void mf_gets(u16 size)
{
 	TCHAR* rbuf;
	
	rbuf = f_gets((TCHAR*)fatbuf,size,file);
	
	if(*rbuf == 0)
	{
		return;//没有数据读到
	}
	else
	{
#ifdef DEBUG_LOG
		printf("\r\nThe String Readed Is:%s\r\n",rbuf);  	
#endif		
	}			    	
}

//需要_USE_STRFUNC>=1
//写一个字符到文件
//c:要写入的字符
//返回值:执行结果
int mf_putc(u8 c)
{
	return f_putc((TCHAR)c,file);
}

//写字符串到文件
//c:要写入的字符串
//返回值:写入的字符串长度
int mf_puts(u8*c)
{
	return f_puts((TCHAR*)c,file);
}













